##  ES6

##### (1). 模板字符串

今后，只要拼接字符串，都用模板字符串代替+: 
a. 整个字符串包裹在一对儿反引号`...`中
b. 反引号``中支持换行、""、''均可使用
c. 反引号中需要动态生成的内容必须放在${}里
d. ${}里: 
  1). 可以放一切有返回值的合法的变量或js表达式。
  2). 不能放程序结构(分支和循环)以及没有返回值的js表达式

##### (2). let

 今后，阻值变量声明提前或控制变量不要超出块作用域，都用let代替var
**a. let的好处:** 
  1). 阻止声明提前
  2). 让代码块(分支和循环的{})也变成块级作用域，{}块内的变量出了{}无法使用，不会影响外部
**b. let的小脾气:** 
  1). 在同一作用域内禁止重复声明; 
  2). 禁止提前使用; 
  3). 在全局声明也不保存在window中
**c. let的原理: 匿名函数自调**



##### (3). 箭头函数

 今后，几乎所有的function都可用箭头函数简写: 
a. 如何: 3句话: 
1). 去掉function，在()和{}之间加=>
2). 如果只有一个形参，可省略()
3). 如果函数体只有一句话，可省略{}
  如果仅有的一句话还是return，必须省略return
b. 特点: 箭头函数内部的this与外部的this，保持一致。
c. 今后:
**1). 如果函数中没有this或者恰好希望函数内this与函数外this保持一致时，可用箭头函数简写！**
**2). 如果不希望内外this相同时不能使用箭头函数简写。**



##### (4). for of

 今后只要遍历数字下标的索引数组、类数组对象和字符串，都用for of
   for in: 今后只要遍历自定义下标名称的对象和关联数组都用for in
                                               for   forEach   for of   for in 
数字下标 索引数组                √         √              √        不保险 
类数组对象                             √          ×             √        不保险 
字符串                                     √          ×             √        不保险 
自定义名称下标 关联数组      ×         ×             ×          √ 
对象                                          ×         ×             ×          √ 



##### (5). 参数增强 

a. 参数默认值: 定义函数时最后一个形参不确定有没有实参时
function 函数名(形参1, ..., 最后形参=默认值){
  ... ...
}
b. 剩余参数: 定义函数时: 只要多个形参不确定，都用剩余参数
function 函数名(其它形参, ...数组名){
  //...收集除其它形参外多余的实参值保存到指定数组名的数组中
}
**c. 打散数组:** 今后调用函数时，只要单纯打散数组再传参时
1). 如何: 函数(...数组)
2). ...口诀: 定义函数时...表示收集, 调用函数时...表示打散
3). ...语法糖: 
  i. 复制一个数组: var arr2=[...arr1];
  ii. 合并多个数组和元素值: var arr3=[...arr1,值,...arr2,值]
  iii. 复制一个对象: var obj2={ ... obj1 }
  iv. 合并多个对象和属性: var obj3={ ...obj1, 属性:值, ...obj2, 属性:值 }



##### (6). 解构 

a. 只要想提取出数组中个别元素值，单独使用时，就数组解构:
  [变量1, 变量2]=arr;

b. 只要想提取出对象中个别属性值或方法，单独使用时，就对象解构: 
var {属性名也是变量名, 属性名也是变量名}=对象
c. 只要多个参数不确定有没有，又要求实参值必须传给指定的形参时，就参数解构: 
定义函数时: 
function 函数名({
  属性名也是形参名="默认值",
  属性名也是形参名="默认值",
  ... = ...
}){
  函数体
}
调用函数时: 
函数名({
  要修改的形参名: 实参值，
  ... : ... ,
})



##### (7). class extends

a. 定义class: 
class 类型名{
  constructor(形参列表){
    this.属性名=形参;
      ... = ...;
  }
  共有方法(){
    ... this.属性 ...
  }
}
class的底层原理和用法与旧js构造函数用法完全相同！——新瓶装旧酒
**b. 继承:** 只要两种类型间包含部分相同的属性结构和方法定义，都要额外定义一个父类型集中保存两种类型相同的属性结构和方法定义。然后再让子类型继承父类型
class 子类型 extends 父类型{
  constructor(...){
    super(...);
    this.属性名=形参;
  }
  子类型共有方法(){
    ... 
  }
}
两步,两个关键字: extends是继承的意思，super()是调用父类型构造函数，请父类型构造函数帮忙添加相同部分的属性的意思。





##### (8). Promise

 当多个异步任务必须顺序执行时，就可用promise
a. 前一项任务: 
function 前一项任务(){
  return new Promise(
    function(resolve, reject){
      原异步任务;
      原异步任务最后一句话之后调用resolve(实参值)，自动执行.then()
      原异步任务执行出错，调用reject(错误提示信息)，自动执行.catch()
    }
  )
}
b. 调用前一项任务时: 
  前一项任务().then(下一项任务).catch(function(msg){ ... })
c. 如果下一项任务也返回new Promise对象，则可以继续用.then()相连
  前一项任务().the(下一项任务).then(之后任务).then(...)....catch(function(msg){ ... })
d. 前后两个任务间传值: 
1). 前一项任务内: 
  resolve(一个变量);
  //只能传一个变量
  //如果传多个值，可放在数组或对象中
2). 后一项任务声明时: 
  function 后一项任务(形参){ ... }
  //前一项任务:resolve()中传什么
  //后一项任务:形参就接住什么
**e. promise三大状态:** 
   new Promise()时，开始执行异步任务
   Promise对象处于pending挂起状态
   当异步任务成功执行，内部调用resolve()后
   Promise对象转换为fulfilled已完成状态，并自动调用.then()
   当异步任务执行出错，内部多用reject()后
   Promise对象转换为rejected出错状态，并自动调用.catch()



##### this  6种

1. obj.fun()  this->点前的obj对象
2. new Fun()   this->new正在创建的新对象
3. 类型名.prototype.共有方法=function(){ ... }  
         this->将来谁调用这个函数，就指谁
         将来调用这个函数的.前的某个子对象
4. fun() 和回调函数 和匿名函数自调 this->默认指window
5. 访问器属性中的this指访问器属性所在的当前对象
6. 在DOM的事件处理函数内的this->当前正在触发事件的DOM元素对象